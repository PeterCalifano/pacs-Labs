
\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{xcolor}
\definecolor{aquagreen}{rgb}{0.85, 1.0, 0.9}
\lstset{
  backgroundcolor=\color{aquagreen},
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true
}


\title{Parallel Kinetic Monte Carlo Simulation with MPI}
\author{Generated by ChatGPT}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]{Overview}
\begin{itemize}
  \item Kinetic Monte Carlo (KMC) simulation of particle diffusion.
  \item Implemented using C++ and MPI for parallel execution.
  \item Each process handles a subset of particles and writes output per timestep.
  \item Post-processing merges per-rank trajectories into global snapshots.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Particle Initialization}
\begin{itemize}
  \item Each MPI rank initializes a subset of the total particles.
  \item Particle positions are drawn from a normal distribution.
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}[language=C++]
std::mt19937 gen(rank + 1);
std::normal_distribution<> noise(0.0, 1.0);
for (int i = 0; i < local_Np; ++i) {
    x_local[i] = noise(gen);
    y_local[i] = noise(gen);
}
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Stepper Class for Brownian Motion}
\begin{itemize}
  \item Each particle evolves via Brownian motion.
  \item Noise is sampled from a Gaussian distribution with variance $2D\Delta t$.
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}[language=C++]
class stepper {
public:
  stepper(std::vector<double>& x, std::vector<double>& y,
          double dt, double D, std::mt19937& gen)
      : x_(x), y_(y), dt_(dt), D_(D),
        noise_(0.0, std::sqrt(2 * D * dt)), gen_(gen) {}

  void operator()(int i) {
      x_[i] += noise_(gen_);
      y_[i] += noise_(gen_);
  }
};
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Time Integration Loop}
\begin{itemize}
  \item At each timestep, the position of each particle is updated.
  \item After each timestep, each rank writes its particle positions to a CSV file.
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}[language=C++]
for (int it = 0; it < Nt; ++it) {
    for (int n = 0; n < local_Np; ++n)
        state(n);
    std::ofstream out("trajectory_rank_" +
                      std::to_string(rank) +
                      "_t" + std::to_string(it) + ".csv");
    for (int i = 0; i < local_Np; ++i)
        out << x_local[i] << "," << y_local[i] << "\n";
    out.close();
}
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Post-processing with \texttt{merge\_trajectories.py}}
\begin{itemize}
  \item The script reads all per-rank CSV files and groups them by timestep.
  \item It merges data from all ranks for each timestep into a single file.
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}[language=Python]
files = glob.glob("trajectory_rank_*_t*.csv")
for timestep in sorted(timestep_dict.keys()):
    frames = [pd.read_csv(f) for _, f in timestep_dict[timestep]]
    merged = pd.concat(frames)
    merged.to_csv(f"merged_trajectories/step_{timestep}.csv")
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Compiling the Code}
\begin{itemize}
  \item Use the provided \texttt{Makefile}.
  \item Compilation command:
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}
make
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Running the Simulation}
\begin{itemize}
  \item Execute with \texttt{mpirun}:
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}
mpirun -np 4 ./kmc_mpi_io
\end{lstlisting}\end{minipage}
\end{frame}

\begin{frame}[fragile]{Running the Post-processing Script}
\begin{itemize}
  \item Make sure \texttt{pandas} is installed.
  \item Then run:
\end{itemize}
\begin{minipage}{\linewidth}\begin{lstlisting}
python3 merge_trajectories.py
\end{lstlisting}\end{minipage}
\end{frame}

\end{document}
