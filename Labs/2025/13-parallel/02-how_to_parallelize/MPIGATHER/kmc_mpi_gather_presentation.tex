\documentclass[10pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{adjustbox}

\definecolor{aquagreen}{RGB}{220,255,240}
\setbeamercolor{block body alerted}{bg=aquagreen}

\title{Parallel Kinetic Monte Carlo with MPI (Gather Strategy)}
\author{Generated with ChatGPT}
\date{\today}

\begin{document}

\begin{frame}[fragile]
  \titlepage
\end{frame}

\begin{frame}[fragile]
\frametitle{Overview}
\begin{itemize}
  \item MPI-based KMC simulation of particle dynamics
  \item Each rank simulates a subset of particles
  \item At each timestep, \textbf{rank 0 gathers all data} and writes to a unified CSV file
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Initialization}
\begin{block}{Code Snippet}
\begin{minipage}{\linewidth}
\begin{minted}[bgcolor=aquagreen]{c++}
MPI_Init(&argc, &argv);
int rank, size;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &size);
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Domain Decomposition}
\begin{block}{Code Snippet}
\begin{minipage}{\linewidth}
\begin{minted}[bgcolor=aquagreen]{c++}
int base_Np = Np / size;
int remainder = Np % size;
int local_Np = base_Np + (rank < remainder ? 1 : 0);
int offset = base_Np * rank + std::min(rank, remainder);
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Initialization of Particles}
\begin{block}{Code Snippet}
\begin{minipage}{\linewidth}
\begin{minted}[bgcolor=aquagreen]{c++}
std::vector<double> x_local(local_Np), y_local(local_Np);
std::mt19937 gen(rank + 1);
std::normal_distribution<> noise(0.0, 1.0);
for (int i = 0; i < local_Np; ++i) {
  x_local[i] = noise(gen);
  y_local[i] = noise(gen);
}
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Time Loop and Data Gathering}
\begin{block}{Code Snippet}
\begin{minipage}{\linewidth}
\begin{minted}[bgcolor=aquagreen]{c++}
MPI_Gatherv(x_local.data(), local_Np, MPI_DOUBLE,
            x_all.data(), counts.data(), displs.data(), MPI_DOUBLE,
            0, MPI_COMM_WORLD);
// same for y_local
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{File Output (Unified CSV)}
\begin{block}{Code Snippet}
\begin{minipage}{\\linewidth}
\begin{minted}[bgcolor=aquagreen]{c++}
if (rank == 0) {
  std::ofstream out("trajectory_t" + std::to_string(it) + ".csv");
  for (int r = 0; r < size; ++r) {
    for (int i = 0; i < counts[r]; ++i) {
      int idx = displs[r] + i;
      out << x_all[idx] << "," << y_all[idx] << "," << r << "\n";
    }
  }
  out.close();
}
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Compilation Instructions}
\begin{block}{Makefile Snippet}
\begin{minipage}{\linewidth}
\begin{minted}[bgcolor=aquagreen]{make}
CXX=mpicxx
all: kmc_mpi_gather
clean: rm -f kmc_mpi_gather *.csv
run: mpirun -np 4 ./kmc_mpi_gather
\end{minted}
\end{minipage}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Post-processing (Optional)}
\begin{itemize}
  \item CSV files \texttt{trajectory\_t\#.csv} contain full positions and rank per timestep
  \item Can be analyzed using scripts (e.g., Python's Pandas or Matplotlib)
\end{itemize}
\end{frame}

\end{document}
